---
description: 
globs: 
alwaysApply: true
---
# Cursor プロジェクトコーディングルール

このドキュメントは、クリーンコードのベストプラクティスに基づいて作成されたプロジェクトのコーディングルールです。コードの可読性、保守性、拡張性を高めるために以下のルールに従いましょう。

## 1. 命名規則

- **変数名は意図が伝わる名前にする**

  - 単一の目的を持ち、名前から内容が推測できるようにする
  - 変数: キャメルケース（例: `userName`）
  - 定数: アッパースネークケース（例: `MAX_RETRY_COUNT`）
  - クラス: パスカルケース（例: `UserProfile`）
  - HTML 属性: ケバブケース（例: `user-profile`）

- **真偽値には適切な接頭語をつける**

  - `is`、`has`、`can`、`should` などの接頭語を使用する（例: `isAdmin`、`hasPermission`）

- **配列には複数形の名前をつける**

  - 配列であることが名前からわかるように（例: `items`、`users`）

- **関数名は動詞(+名詞)の形式にする**

  - 何をするかが明確な名前をつける（例: `getUserData`、`validateEmail`）

- **嘘の名前をつけない**
  - 格納している値が名前と一致していることを確認する

## 2. コメント

- **コードでわかることはコメントに書かない**

  - コードで意図を表現し、必要な場合のみコメントを追加する

- **良いコメントの例**

  - TODO コメント：後で対応する項目を明示
  - 使用上の注意点や警告
  - パフォーマンスに関わる説明
  - 複雑な正規表現の意図説明

- **悪いコメントの例**
  - コードから明らかなことを繰り返すコメント
  - コメントアウトされたままのコード
  - 冗長な説明
  - 情報がない、または間違った情報を含むコメント

## 3. 変数

- **マジックナンバー・マジックキャラクタを避ける**

  - 数値や文字列は意味のある名前の定数として定義する（例: `const TAX_RATE = 0.1`）

- **変数は一つの目的にのみ使用する**

  - 複数の目的で同じ変数を再利用しない

- **オブジェクトや配列は定数（const）で定義する**

  - 再代入されないようにする

- **変数の寿命を短くする**

  - 変数は使用する場所の直前で宣言する
  - スコープをなるべく小さくする

- **分割代入を活用する**
  - 配列やオブジェクトからデータを取り出す際は添字やキー指定より分割代入を使う

## 4. 関数

- **関数は小さく、一つの責務のみを持つようにする**

  - 単一の機能を実装し、20 行を超えないように心がける

- **引数は少なくする**

  - 引数が多い場合はオブジェクトにまとめる

- **早期 return を活用する**

  - 条件に合わない場合は早めに関数を終了させる

- **DRY 原則（Don't Repeat Yourself）を遵守する**

  - 同じコードを繰り返し書かない
  - 共通の処理は関数に抽出する

- **関数は使用順に上から下に書く**

  - 縦方向のフォーマットを整える

- **複雑な条件式は関数に切り出す**
  - 条件式が複雑な場合は、その条件を表す関数に切り出す

## 5. ループと繰り返し処理

- **for 文と while 文を適切に使い分ける**

  - ループ回数が決まっている場合: for 文
  - 条件によってループを抜ける場合: while 文

- **同じループ内で複数のことをしない**

  - ループは一つの目的のために使用する

- **for 文のカウンタ変数は本文内で書き換えない**

  - ループ制御は for 文の初期化部分のみで行う

- **高階関数を活用する**
  - forEach, map, filter などの配列メソッドを積極的に使用する

## 6. 条件分岐

- **厳密な等価性チェックを使用する**

  - `==` ではなく `===` を使用する

- **一般的な条件から評価する**

  - 最も起こりやすいケースを最初に評価する

- **switch 文より連想配列を使う**

  - 単純な分岐は連想配列（オブジェクト）でマッピングする

- **ネストを深くしない**

  - 早期 return や guard 節を使ってネストを減らす

- **同じ条件分岐はあちこちに書かない**
  - 共通の判定ロジックは関数に抽出する

## 7. クラス

- **クラスは小さくする**

  - 単一責任の原則に従い、一つのクラスは一つの責任だけを持つ

- **クラス内部の情報は隠蔽する**

  - プライベートフィールドやメソッドを使用して内部実装を隠す

- **継承よりコンポジションを検討する**

  - is-a 関係なら継承、has-a 関係ならコンポジションを使用する

- **高凝集・疎結合を目指す**
  - 関連する機能やデータをまとめ、クラス間の依存を最小限にする

## 8. SOLID 原則

- **単一責任の原則**: クラスは一つの責任のみを持つ
- **オープン・クローズドの原則**: 拡張には開いていて、修正には閉じている
- **リスコフの置換原則**: 派生クラスは基底クラスと置換可能である
- **インターフェース分離の原則**: 利用者に必要のないインターフェースを強制しない
- **依存性逆転の原則**: 抽象に依存し、具象に依存しない

## 9. 共通ガイドライン

- **コードをフォーマットする**

  - インデントと空白を適切に使用し、水平・垂直フォーマットを整える

- **副作用を限定的にする**

  - 関数は純粋関数として定義し、副作用を明示的にする

- **引数で渡されたオブジェクトの中身を書き換えない**

  - 引数のオブジェクトは変更せず、新しいオブジェクトを返す

- **テストしやすいコードを書く**
  - 依存関係を明示的にし、モック可能な設計にする

以上のルールを遵守することで、チーム全体のコード品質が向上し、長期的なメンテナンスが容易になります。
